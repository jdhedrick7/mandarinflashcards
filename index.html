<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>‰∏≠Êñá Flashcards - Learn 100 Essential Chinese Words</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      margin: 0;
      padding: 0;
    }
    html, body, #root {
      height: 100%;
      width: 100%;
    }
    body {
      font-family: 'Noto Sans SC', 'Segoe UI', sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    input::placeholder {
      color: #c0b0a0;
    }
    input:focus {
      border-color: #ff8b5a !important;
      outline: none;
    }
    button {
      border: none;
      cursor: pointer;
      font-family: inherit;
    }
    button:active {
      transform: scale(0.98);
    }
    button:disabled {
      cursor: not-allowed;
    }
    /* Prevent iOS zoom on input focus */
    input {
      font-size: 16px !important;
    }
    @media (min-width: 768px) {
      input {
        font-size: 20px !important;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useCallback, useEffect } = React;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // COMPLETE VOCABULARY DATA (100 words)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const VOCABULARY = [
      { id: 1, chinese: 'Êàë', pinyin: 'w«í', english: 'I; me' },
      { id: 2, chinese: '‰Ω†', pinyin: 'n«ê', english: 'you' },
      { id: 3, chinese: '‰ªñ', pinyin: 'tƒÅ', english: 'he; him' },
      { id: 4, chinese: 'Â•π', pinyin: 'tƒÅ', english: 'she; her' },
      { id: 5, chinese: 'Êàë‰ª¨', pinyin: 'w«ímen', english: 'we; us' },
      { id: 6, chinese: '‰Ω†‰ª¨', pinyin: 'n«êmen', english: 'you (plural)' },
      { id: 7, chinese: 'ÊòØ', pinyin: 'sh√¨', english: 'to be (am/is/are)' },
      { id: 8, chinese: 'Êúâ', pinyin: 'y«íu', english: 'to have; there is/are' },
      { id: 9, chinese: 'Ë¶Å', pinyin: 'y√†o', english: 'to want; going to' },
      { id: 10, chinese: 'ÊÉ≥', pinyin: 'xi«éng', english: 'to think; to want; to miss' },
      { id: 11, chinese: 'ÂñúÊ¨¢', pinyin: 'x«êhuan', english: 'to like' },
      { id: 12, chinese: 'Áà±', pinyin: '√†i', english: 'to love' },
      { id: 13, chinese: 'Áü•ÈÅì', pinyin: 'zhƒ´dao', english: 'to know' },
      { id: 14, chinese: 'ËßâÂæó', pinyin: 'ju√©de', english: 'to feel; to think' },
      { id: 15, chinese: 'Áúã', pinyin: 'k√†n', english: 'to look; to watch' },
      { id: 16, chinese: 'Âê¨', pinyin: 'tƒ´ng', english: 'to listen' },
      { id: 17, chinese: 'ËØ¥', pinyin: 'shu≈ç', english: 'to speak; to say' },
      { id: 18, chinese: 'Âéª', pinyin: 'q√π', english: 'to go' },
      { id: 19, chinese: 'ÂèØ‰ª•', pinyin: 'kƒõy«ê', english: 'can; may' },
      { id: 20, chinese: '‰ºö', pinyin: 'hu√¨', english: 'can; be able to; will' },
      { id: 21, chinese: 'Áªô', pinyin: 'gƒõi', english: 'to give; for' },
      { id: 22, chinese: 'Â•Ω', pinyin: 'h«éo', english: 'good' },
      { id: 23, chinese: 'ÊºÇ‰∫Æ', pinyin: 'pi√†oliang', english: 'pretty; beautiful' },
      { id: 24, chinese: 'Â∏Ö', pinyin: 'shu√†i', english: 'handsome' },
      { id: 25, chinese: 'ÂèØÁà±', pinyin: "kƒõ'√†i", english: 'cute; adorable' },
      { id: 26, chinese: 'Ê∏©Êüî', pinyin: 'wƒìnr√≥u', english: 'gentle; soft (personality)' },
      { id: 27, chinese: 'Áîú', pinyin: 'ti√°n', english: 'sweet' },
      { id: 28, chinese: 'Êµ™Êº´', pinyin: 'l√†ngm√†n', english: 'romantic' },
      { id: 29, chinese: 'ÈáçË¶Å', pinyin: 'zh√≤ngy√†o', english: 'important' },
      { id: 30, chinese: 'ÁâπÂà´', pinyin: 't√®bi√©', english: 'special; especially' },
      { id: 31, chinese: 'ÂºÄÂøÉ', pinyin: 'kƒÅixƒ´n', english: 'happy (in a good mood)' },
      { id: 32, chinese: 'Âπ∏Á¶è', pinyin: 'x√¨ngf√∫', english: 'happy; blessed (deep happiness)' },
      { id: 33, chinese: 'ÂÆ≥Áæû', pinyin: 'h√†ixi≈´', english: 'shy' },
      { id: 34, chinese: 'Á¥Ø', pinyin: 'l√®i', english: 'tired' },
      { id: 35, chinese: 'Âøô', pinyin: 'm√°ng', english: 'busy' },
      { id: 36, chinese: 'ÂÆâÂÖ®', pinyin: 'ƒÅnqu√°n', english: 'safe' },
      { id: 37, chinese: 'ËàíÊúç', pinyin: 'sh≈´fu', english: 'comfortable' },
      { id: 38, chinese: 'Â•≥ÊúãÂèã', pinyin: 'n«öp√©ngyou', english: 'girlfriend' },
      { id: 39, chinese: 'Áî∑ÊúãÂèã', pinyin: 'n√°np√©ngyou', english: 'boyfriend' },
      { id: 40, chinese: 'ÂÆùË¥ù', pinyin: 'b«éob√®i', english: 'baby; darling' },
      { id: 41, chinese: '‰∫≤Áà±ÁöÑ', pinyin: "qƒ´n'√†i de", english: 'dear; darling' },
      { id: 42, chinese: 'ËÄÅÂÖ¨', pinyin: 'l«éog≈çng', english: 'husband (informal)' },
      { id: 43, chinese: 'ËÄÅÂ©Ü', pinyin: 'l«éop√≥', english: 'wife (informal)' },
      { id: 44, chinese: 'ÂÆ∂', pinyin: 'jiƒÅ', english: 'home; family' },
      { id: 45, chinese: 'ÂøÉ', pinyin: 'xƒ´n', english: 'heart' },
      { id: 46, chinese: 'Ë∫´‰Ωì', pinyin: 'shƒìnt«ê', english: 'body; health' },
      { id: 47, chinese: 'ÁúºÁùõ', pinyin: 'y«énjing', english: 'eyes' },
      { id: 48, chinese: 'Êâã', pinyin: 'sh«íu', english: 'hand' },
      { id: 49, chinese: 'ÊâãÊú∫', pinyin: 'sh«íujƒ´', english: 'cellphone' },
      { id: 50, chinese: 'Â∑•‰Ωú', pinyin: 'g≈çngzu√≤', english: 'work; job' },
      { id: 51, chinese: 'Â≠¶Ê†°', pinyin: 'xu√©xi√†o', english: 'school' },
      { id: 52, chinese: 'ÁîµÂΩ±', pinyin: 'di√†ny«êng', english: 'movie' },
      { id: 53, chinese: 'Èü≥‰πê', pinyin: 'yƒ´nyu√®', english: 'music' },
      { id: 54, chinese: '‰ªäÂ§©', pinyin: 'jƒ´ntiƒÅn', english: 'today' },
      { id: 55, chinese: 'ÊòéÂ§©', pinyin: 'm√≠ngtiƒÅn', english: 'tomorrow' },
      { id: 56, chinese: 'Áé∞Âú®', pinyin: 'xi√†nz√†i', english: 'now' },
      { id: 57, chinese: '‰ªäÊôö', pinyin: 'jƒ´nw«én', english: 'tonight' },
      { id: 58, chinese: '‰∏ÄÁõ¥', pinyin: 'yƒ´zh√≠', english: 'all the time; continuously' },
      { id: 59, chinese: 'Â∑≤Áªè', pinyin: 'y«êjƒ´ng', english: 'already' },
      { id: 60, chinese: 'Ëøò', pinyin: 'h√°i', english: 'still; also' },
      { id: 61, chinese: 'Âæà', pinyin: 'hƒõn', english: 'very' },
      { id: 62, chinese: '‰πü', pinyin: 'yƒõ', english: 'also' },
      { id: 63, chinese: 'ÈÉΩ', pinyin: 'd≈çu', english: 'all; both' },
      { id: 64, chinese: 'ËøôÂÑø', pinyin: 'zh√®r', english: 'here' },
      { id: 65, chinese: 'ÈÇ£ÂÑø', pinyin: 'n√†r', english: 'there' },
      { id: 66, chinese: 'ËøôÈáå', pinyin: 'zh√®l«ê', english: 'here' },
      { id: 67, chinese: 'ÈÇ£Èáå', pinyin: 'n√†l«ê', english: 'there' },
      { id: 68, chinese: '‰∏ÄËµ∑', pinyin: 'y√¨q«ê', english: 'together' },
      { id: 69, chinese: 'ÂÜç', pinyin: 'z√†i', english: 'again; more' },
      { id: 70, chinese: 'Â§ö', pinyin: 'du≈ç', english: 'many; much; more' },
      { id: 71, chinese: 'Â∞ë', pinyin: 'sh«éo', english: 'few; little; less' },
      { id: 72, chinese: 'Âêó', pinyin: 'ma', english: 'question particle (yes/no)' },
      { id: 73, chinese: 'Âë¢', pinyin: 'ne', english: 'question particle / "and‚Ä¶?"' },
      { id: 74, chinese: 'Âêß', pinyin: 'ba', english: 'softening/suggestion particle' },
      { id: 75, chinese: 'Âïä', pinyin: 'a', english: 'exclamation/ending particle' },
      { id: 76, chinese: 'ÁöÑ', pinyin: 'de', english: "possessive particle" },
      { id: 77, chinese: '‰∫Ü', pinyin: 'le', english: 'completed action / change' },
      { id: 78, chinese: 'Âíå', pinyin: 'h√©', english: 'and; with' },
      { id: 79, chinese: 'Âõ†‰∏∫', pinyin: 'yƒ´nw√®i', english: 'because' },
      { id: 80, chinese: 'ÊâÄ‰ª•', pinyin: 'su«íy«ê', english: 'so; therefore' },
      { id: 81, chinese: '‰ΩÜÊòØ', pinyin: 'd√†nsh√¨', english: 'but; however' },
      { id: 82, chinese: 'Êã•Êä±', pinyin: 'y≈çngb√†o', english: 'hug' },
      { id: 83, chinese: '‰∫≤', pinyin: 'qƒ´n', english: 'to kiss' },
      { id: 84, chinese: 'ÁâµÊâã', pinyin: 'qiƒÅnsh«íu', english: 'to hold hands' },
      { id: 85, chinese: 'ÊÉ≥‰Ω†', pinyin: 'xi«éng n«ê', english: '(I) miss you' },
      { id: 86, chinese: 'Êä±Êä±', pinyin: 'b√†obao', english: 'hug-hug; give me a hug' },
      { id: 87, chinese: '‰∫≤‰∫≤', pinyin: 'qƒ´nqin', english: 'kiss-kiss; give me a kiss' },
      { id: 88, chinese: 'ËßÅÈù¢', pinyin: 'ji√†nmi√†n', english: 'to meet (in person)' },
      { id: 89, chinese: 'Á∫¶‰ºö', pinyin: 'yuƒìhu√¨', english: 'date; to go on a date' },
      { id: 90, chinese: 'Á≠â‰Ω†', pinyin: 'dƒõng n«ê', english: 'wait for you' },
      { id: 91, chinese: 'Èô™‰Ω†', pinyin: 'p√©i n«ê', english: 'keep you company; be with you' },
      { id: 92, chinese: 'ÊÉ≥Âøµ‰Ω†', pinyin: 'xi«éngni√†n n«ê', english: 'miss you (deeply)' },
      { id: 93, chinese: 'ÁÖßÈ°æ‰Ω†', pinyin: 'zh√†ogu n«ê', english: 'take care of you' },
      { id: 94, chinese: 'ÊàëÁà±‰Ω†', pinyin: 'w«í √†i n«ê', english: 'I love you' },
      { id: 95, chinese: 'ÊàëÊÉ≥‰Ω†', pinyin: 'w«í xi«éng n«ê', english: 'I miss you' },
      { id: 96, chinese: 'ÊôöÂÆâ', pinyin: "w«én'ƒÅn", english: 'good night' },
      { id: 97, chinese: 'Êó©ÂÆâ', pinyin: "z«éo'ƒÅn", english: 'good morning' },
      { id: 98, chinese: 'ÊÉ≥Êä±‰Ω†', pinyin: 'xi«éng b√†o n«ê', english: '(I) want to hug you' },
      { id: 99, chinese: 'ÊÉ≥‰∫≤‰Ω†', pinyin: 'xi«éng qƒ´n n«ê', english: '(I) want to kiss you' },
      { id: 100, chinese: 'ÊàëÊÉ≥ËßÅ‰Ω†', pinyin: 'w«í xi«éng ji√†n n«ê', english: 'I want to see you' },
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE STRUCTURE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const generatePhaseStructure = () => {
      const phases = { '1': [], '1.5': [], '2': [], '3': [] };
      for (let i = 0; i < 20; i++) {
        phases['1'].push({ id: `1-${i + 1}`, phase: '1', groupNum: i + 1, words: VOCABULARY.slice(i * 5, (i + 1) * 5), label: `Group ${i + 1}` });
      }
      for (let i = 0; i < 10; i++) {
        phases['1.5'].push({ id: `1.5-${i + 1}`, phase: '1.5', groupNum: i + 1, words: VOCABULARY.slice(i * 10, (i + 1) * 10), label: `Group ${i + 1}`, requires: [`1-${i * 2 + 1}`, `1-${i * 2 + 2}`] });
      }
      for (let i = 0; i < 5; i++) {
        phases['2'].push({ id: `2-${i + 1}`, phase: '2', groupNum: i + 1, words: VOCABULARY.slice(i * 20, (i + 1) * 20), label: `Group ${i + 1}`, requires: [`1.5-${i * 2 + 1}`, `1.5-${i * 2 + 2}`] });
      }
      phases['3'].push({ id: '3-1', phase: '3', groupNum: 1, words: [...VOCABULARY], label: 'Final Review', requires: ['2-1', '2-2', '2-3', '2-4', '2-5'] });
      return phases;
    };

    const PHASES = generatePhaseStructure();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UTILITIES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const shuffle = (array) => {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    };

    const weightedShuffle = (cards, failedIds) => {
      const failed = cards.filter(c => failedIds.has(c.id));
      const notFailed = cards.filter(c => !failedIds.has(c.id));
      const shuffledFailed = shuffle(failed);
      const shuffledNotFailed = shuffle(notFailed);
      const frontFailed = shuffledFailed.slice(0, Math.ceil(shuffledFailed.length * 0.6));
      const backFailed = shuffledFailed.slice(Math.ceil(shuffledFailed.length * 0.6));
      return [...frontFailed, ...shuffle([...shuffledNotFailed, ...backFailed])];
    };

    const normalizeInput = (str) => str.trim().toLowerCase().replace(/\s+/g, ' ').replace(/['\']/g, "'");

    const loadFromStorage = (key, defaultValue) => {
      try {
        const saved = localStorage.getItem(key);
        return saved ? JSON.parse(saved) : defaultValue;
      } catch {
        return defaultValue;
      }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MAIN APP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function FlashcardApp() {
      const [sidebarOpen, setSidebarOpen] = useState(false);
      const [currentGroup, setCurrentGroup] = useState(null);
      const [groupProgress, setGroupProgress] = useState(() => loadFromStorage('fc-progress', {}));
      const [confidenceQueue, setConfidenceQueue] = useState(() => loadFromStorage('fc-confidence', []));
      const [roundCards, setRoundCards] = useState([]);
      const [currentCardIndex, setCurrentCardIndex] = useState(0);
      const [roundErrors, setRoundErrors] = useState(0);
      const [roundErrorIds, setRoundErrorIds] = useState(new Set());
      const [userInput, setUserInput] = useState('');
      const [showAnswer, setShowAnswer] = useState(false);
      const [practiceMode, setPracticeMode] = useState(false);
      const [feedback, setFeedback] = useState(null);
      const [allTimeStats, setAllTimeStats] = useState(() => loadFromStorage('fc-stats', { correct: 0, total: 0 }));
      const [currentStreak, setCurrentStreak] = useState(0);
      const [roundStartTime, setRoundStartTime] = useState(null);
      const [cardsAnsweredThisRound, setCardsAnsweredThisRound] = useState(0);
      const [miniReviewPending, setMiniReviewPending] = useState(false);
      const [masteredSinceLastReview, setMasteredSinceLastReview] = useState(0);
      const [isMiniReview, setIsMiniReview] = useState(false);
      const [isConfidenceReview, setIsConfidenceReview] = useState(false);
      const [confidenceGroupId, setConfidenceGroupId] = useState(null);

      const inputRef = useRef(null);

      // Persistence
      useEffect(() => {
        localStorage.setItem('fc-progress', JSON.stringify(groupProgress));
      }, [groupProgress]);

      useEffect(() => {
        localStorage.setItem('fc-confidence', JSON.stringify(confidenceQueue));
      }, [confidenceQueue]);

      useEffect(() => {
        localStorage.setItem('fc-stats', JSON.stringify(allTimeStats));
      }, [allTimeStats]);

      const isGroupUnlocked = useCallback((groupId) => {
        const [phase] = groupId.split('-');
        if (phase === '1') return true;
        const group = [...PHASES['1'], ...PHASES['1.5'], ...PHASES['2'], ...PHASES['3']].find(g => g.id === groupId);
        if (!group?.requires) return true;
        return group.requires.every(reqId => groupProgress[reqId]?.mastered);
      }, [groupProgress]);

      const getGroupStatus = useCallback((groupId) => {
        const progress = groupProgress[groupId];
        if (progress?.mastered) return 'mastered';
        if (progress?.passed) return 'passed';
        if (!isGroupUnlocked(groupId)) return 'locked';
        if (progress?.perfectRounds > 0) return 'in-progress';
        return 'available';
      }, [groupProgress, isGroupUnlocked]);

      const needsReview = useCallback((groupId) => {
        const progress = groupProgress[groupId];
        if (!progress?.lastSeen) return false;
        const hoursSince = (Date.now() - progress.lastSeen) / (1000 * 60 * 60);
        return hoursSince >= 24 && progress.mastered;
      }, [groupProgress]);

      const startGroup = useCallback((groupId, isConfidence = false, isMini = false) => {
        let words;
        let group;
        if (isMini) {
          const masteredGroups = Object.entries(groupProgress).filter(([, p]) => p.mastered).sort((a, b) => (b[1].lastSeen || 0) - (a[1].lastSeen || 0)).slice(0, 5);
          const allWords = [];
          masteredGroups.forEach(([gId]) => {
            const g = [...PHASES['1'], ...PHASES['1.5'], ...PHASES['2'], ...PHASES['3']].find(grp => grp.id === gId);
            if (g) allWords.push(...g.words);
          });
          words = shuffle(allWords).slice(0, 15);
          if (words.length === 0) return;
          setIsMiniReview(true);
          setIsConfidenceReview(false);
          setConfidenceGroupId(null);
        } else {
          group = [...PHASES['1'], ...PHASES['1.5'], ...PHASES['2'], ...PHASES['3']].find(g => g.id === groupId);
          if (!group) return;
          words = [...group.words];
          setIsMiniReview(false);
          setIsConfidenceReview(isConfidence);
          setConfidenceGroupId(isConfidence ? groupId : null);
        }
        setCurrentGroup(isMini ? { id: 'mini-review', label: 'Mini Review', phase: '‚òÖ', words } : group);
        setRoundCards(shuffle(words));
        setCurrentCardIndex(0);
        setRoundErrors(0);
        setRoundErrorIds(new Set());
        setUserInput('');
        setShowAnswer(false);
        setPracticeMode(false);
        setFeedback(null);
        setRoundStartTime(Date.now());
        setCardsAnsweredThisRound(0);
        setSidebarOpen(false);
        setTimeout(() => inputRef.current?.focus(), 100);
      }, [groupProgress]);

      const completeRound = useCallback(() => {
        if (!currentGroup) return;
        const errors = roundErrors;

        if (isMiniReview) {
          setMasteredSinceLastReview(0);
          setMiniReviewPending(false);
          setIsMiniReview(false);
          setCurrentGroup(null);
          return;
        }

        if (isConfidenceReview) {
          if (errors === 0) {
            setGroupProgress(prev => ({ ...prev, [confidenceGroupId]: { ...prev[confidenceGroupId], mastered: true, lastSeen: Date.now() } }));
            setConfidenceQueue(prev => prev.filter(id => id !== confidenceGroupId));
            setMasteredSinceLastReview(prev => { const newVal = prev + 1; if (newVal >= 3) setMiniReviewPending(true); return newVal; });
          }
          setIsConfidenceReview(false);
          setConfidenceGroupId(null);
          setCurrentGroup(null);
          return;
        }

        const groupId = currentGroup.id;
        const currentProgress = groupProgress[groupId] || { perfectRounds: 0, passed: false, mastered: false };
        let newPerfectRounds = currentProgress.perfectRounds;

        if (errors === 0) newPerfectRounds += 1;
        else if (errors >= 2 && errors <= 3) newPerfectRounds = Math.max(0, newPerfectRounds - 1);
        else if (errors >= 4) newPerfectRounds = 0;

        const passed = newPerfectRounds >= 3;
        setGroupProgress(prev => ({ ...prev, [groupId]: { ...currentProgress, perfectRounds: passed ? 3 : newPerfectRounds, passed, lastSeen: Date.now() } }));

        if (passed && !currentProgress.passed) setConfidenceQueue(prev => [...prev, groupId]);

        if (!passed) {
          const nextCards = weightedShuffle(currentGroup.words, roundErrorIds);
          setRoundCards(nextCards);
          setCurrentCardIndex(0);
          setRoundErrors(0);
          setRoundErrorIds(new Set());
          setUserInput('');
          setShowAnswer(false);
          setPracticeMode(false);
          setFeedback(null);
          setCardsAnsweredThisRound(0);
          setRoundStartTime(Date.now());
          setTimeout(() => inputRef.current?.focus(), 100);
        } else {
          setCurrentGroup(null);
        }
      }, [currentGroup, roundErrors, roundErrorIds, groupProgress, isMiniReview, isConfidenceReview, confidenceGroupId]);

      const moveToNextCard = useCallback(() => {
        if (currentCardIndex + 1 < roundCards.length) {
          setCurrentCardIndex(prev => prev + 1);
          setUserInput('');
          setShowAnswer(false);
          setTimeout(() => inputRef.current?.focus(), 50);
        } else {
          completeRound();
        }
      }, [currentCardIndex, roundCards.length, completeRound]);

      const checkAnswer = useCallback(() => {
        if (!currentGroup || currentCardIndex >= roundCards.length) return;
        const card = roundCards[currentCardIndex];
        const input = normalizeInput(userInput);
        const correctChinese = normalizeInput(card.chinese);
        const correctPinyin = normalizeInput(card.pinyin);
        const isCorrect = input === correctChinese || input === correctPinyin;

        if (practiceMode) {
          if (isCorrect) {
            setPracticeMode(false);
            setShowAnswer(false);
            setFeedback('correct');
            setTimeout(() => { setFeedback(null); moveToNextCard(); }, 600);
          } else {
            setFeedback('incorrect');
            setTimeout(() => setFeedback(null), 400);
          }
          setUserInput('');
          return;
        }

        if (isCorrect) {
          setAllTimeStats(prev => ({ correct: prev.correct + 1, total: prev.total + 1 }));
          setCurrentStreak(prev => prev + 1);
          setCardsAnsweredThisRound(prev => prev + 1);
          setFeedback('correct');
          setTimeout(() => { setFeedback(null); moveToNextCard(); }, 600);
        } else {
          setAllTimeStats(prev => ({ ...prev, total: prev.total + 1 }));
          setCurrentStreak(0);
          setRoundErrors(prev => prev + 1);
          setRoundErrorIds(prev => new Set([...prev, card.id]));
          setFeedback('incorrect');
        }
        setUserInput('');
      }, [currentGroup, currentCardIndex, roundCards, userInput, practiceMode, moveToNextCard]);

      const handleDontKnow = useCallback(() => {
        if (!currentGroup || currentCardIndex >= roundCards.length) return;
        const card = roundCards[currentCardIndex];
        setAllTimeStats(prev => ({ ...prev, total: prev.total + 1 }));
        setCurrentStreak(0);
        setRoundErrors(prev => prev + 1);
        setRoundErrorIds(prev => new Set([...prev, card.id]));
        setShowAnswer(true);
        setPracticeMode(true);
        setUserInput('');
        setTimeout(() => inputRef.current?.focus(), 100);
      }, [currentGroup, currentCardIndex, roundCards]);

      const handleKeyDown = useCallback((e) => {
        if (e.key === 'Enter') { e.preventDefault(); if (userInput.trim()) checkAnswer(); }
      }, [userInput, checkAnswer]);

      const resetProgress = () => {
        if (window.confirm('Reset all progress? This cannot be undone.')) {
          setGroupProgress({});
          setConfidenceQueue([]);
          setAllTimeStats({ correct: 0, total: 0 });
          setCurrentGroup(null);
          setCurrentStreak(0);
          localStorage.removeItem('fc-progress');
          localStorage.removeItem('fc-confidence');
          localStorage.removeItem('fc-stats');
        }
      };

      const accuracy = allTimeStats.total > 0 ? Math.round((allTimeStats.correct / allTimeStats.total) * 100) : 100;
      const currentCard = roundCards[currentCardIndex];
      const currentPerfectRounds = currentGroup && !isMiniReview && !isConfidenceReview ? (groupProgress[currentGroup.id]?.perfectRounds || 0) : 0;
      const estimatedTimeRemaining = roundStartTime && cardsAnsweredThisRound > 0 ? Math.round(((Date.now() - roundStartTime) / cardsAnsweredThisRound) * (roundCards.length - currentCardIndex) / 1000) : null;

      const styles = {
        container: {
          minHeight: '100vh',
          background: 'linear-gradient(145deg, #fef6e4 0%, #f9e4d4 50%, #fce8d5 100%)',
          position: 'relative',
          overflow: 'hidden',
        },
        bgDecor1: {
          position: 'fixed',
          top: '-20%',
          right: '-10%',
          width: '50%',
          height: '60%',
          background: 'radial-gradient(ellipse, rgba(255,182,147,0.3) 0%, transparent 70%)',
          pointerEvents: 'none',
        },
        bgDecor2: {
          position: 'fixed',
          bottom: '-10%',
          left: '-10%',
          width: '40%',
          height: '50%',
          background: 'radial-gradient(ellipse, rgba(255,214,186,0.4) 0%, transparent 70%)',
          pointerEvents: 'none',
        },
        header: {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          padding: '16px 20px',
          background: 'rgba(255,255,255,0.7)',
          backdropFilter: 'blur(10px)',
          borderBottom: '1px solid rgba(0,0,0,0.05)',
          position: 'sticky',
          top: 0,
          zIndex: 100,
        },
        menuBtn: {
          width: '48px',
          height: '48px',
          borderRadius: '12px',
          background: sidebarOpen ? '#ff8b5a' : 'white',
          color: sidebarOpen ? 'white' : '#5a4a3f',
          fontSize: '24px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        },
        sidebar: {
          position: 'fixed',
          top: 0,
          left: 0,
          width: '300px',
          height: '100vh',
          background: 'white',
          boxShadow: '4px 0 20px rgba(0,0,0,0.1)',
          transform: sidebarOpen ? 'translateX(0)' : 'translateX(-100%)',
          transition: 'transform 0.3s ease',
          zIndex: 200,
          overflowY: 'auto',
          padding: '20px',
        },
        overlay: {
          position: 'fixed',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          background: 'rgba(0,0,0,0.3)',
          zIndex: 150,
        },
        main: {
          padding: '20px',
          maxWidth: '500px',
          margin: '0 auto',
          position: 'relative',
          zIndex: 1,
        },
        card: {
          background: 'white',
          borderRadius: '24px',
          padding: '32px 24px',
          marginBottom: '16px',
          boxShadow: '0 8px 32px rgba(0,0,0,0.1)',
          textAlign: 'center',
          position: 'relative',
          overflow: 'hidden',
          transform: feedback === 'correct' ? 'scale(1.02)' : feedback === 'incorrect' ? 'translateX(4px)' : 'scale(1)',
          transition: 'transform 0.15s ease',
          borderLeft: feedback === 'correct' ? '4px solid #22c55e' : feedback === 'incorrect' ? '4px solid #ef4444' : 'none',
        },
      };

      return (
        <div style={styles.container}>
          <div style={styles.bgDecor1} />
          <div style={styles.bgDecor2} />

          {/* Header */}
          <header style={styles.header}>
            <button onClick={() => setSidebarOpen(!sidebarOpen)} style={styles.menuBtn}>‚ò∞</button>
            <div style={{ textAlign: 'center' }}>
              <h1 style={{ fontSize: '18px', fontWeight: '700', color: '#5a4a3f', margin: 0 }}>‰∏≠Êñá Flashcards</h1>
              <p style={{ fontSize: '12px', color: '#8a7a6f', margin: '2px 0 0 0' }}>{accuracy}% accuracy ‚Ä¢ {currentStreak} streak üî•</p>
            </div>
            <div style={{ width: '48px' }} />
          </header>

          {/* Sidebar */}
          <div style={styles.sidebar}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '24px' }}>
              <h2 style={{ margin: 0, color: '#5a4a3f', fontSize: '20px' }}>Phases</h2>
              <button onClick={() => setSidebarOpen(false)} style={{ width: '36px', height: '36px', borderRadius: '8px', background: '#f5f0eb', color: '#5a4a3f', fontSize: '18px' }}>√ó</button>
            </div>

            {confidenceQueue.length > 0 && (
              <div style={{ background: 'linear-gradient(135deg, #fff3e6, #ffe8d6)', borderRadius: '12px', padding: '12px', marginBottom: '16px', border: '2px solid #ffb366' }}>
                <h3 style={{ margin: '0 0 8px 0', fontSize: '14px', color: '#cc6600' }}>‚è∞ Confidence Review ({confidenceQueue.length})</h3>
                {confidenceQueue.slice(0, 3).map(gId => {
                  const g = [...PHASES['1'], ...PHASES['1.5'], ...PHASES['2'], ...PHASES['3']].find(gr => gr.id === gId);
                  return <button key={gId} onClick={() => startGroup(gId, true)} style={{ display: 'block', width: '100%', padding: '8px 12px', marginTop: '6px', borderRadius: '8px', background: 'white', color: '#cc6600', fontSize: '13px', textAlign: 'left' }}>Phase {g?.phase} - {g?.label}</button>;
                })}
              </div>
            )}

            {miniReviewPending && (
              <button onClick={() => startGroup(null, false, true)} style={{ display: 'block', width: '100%', padding: '14px', marginBottom: '16px', borderRadius: '12px', background: 'linear-gradient(135deg, #a855f7, #7c3aed)', color: 'white', fontSize: '14px', fontWeight: '600' }}>‚ö° Mini Review Ready!</button>
            )}

            {['1', '1.5', '2', '3'].map(phaseKey => (
              <div key={phaseKey} style={{ marginBottom: '20px' }}>
                <h3 style={{ fontSize: '13px', fontWeight: '700', color: '#8a7a6f', textTransform: 'uppercase', letterSpacing: '1px', margin: '0 0 10px 0' }}>
                  Phase {phaseKey} <span style={{ marginLeft: '8px', fontWeight: '400', fontSize: '11px' }}>({phaseKey === '1' ? '5 words' : phaseKey === '1.5' ? '10 words' : phaseKey === '2' ? '20 words' : '100 words'})</span>
                </h3>
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                  {PHASES[phaseKey].map(group => {
                    const status = getGroupStatus(group.id);
                    const review = needsReview(group.id);
                    const progress = groupProgress[group.id];
                    return (
                      <button key={group.id} onClick={() => status !== 'locked' && startGroup(group.id)} disabled={status === 'locked'} style={{
                        position: 'relative',
                        minWidth: '60px',
                        padding: '10px 12px',
                        borderRadius: '10px',
                        background: status === 'mastered' ? 'linear-gradient(135deg, #22c55e, #16a34a)' : status === 'passed' ? 'linear-gradient(135deg, #60a5fa, #3b82f6)' : status === 'in-progress' ? 'linear-gradient(135deg, #ff8b5a, #f97316)' : status === 'available' ? 'white' : '#e5e5e5',
                        color: status === 'locked' ? '#a0a0a0' : status === 'available' ? '#5a4a3f' : 'white',
                        fontSize: '12px',
                        fontWeight: '600',
                        boxShadow: status === 'available' ? '0 2px 6px rgba(0,0,0,0.1)' : 'none',
                        opacity: status === 'locked' ? 0.5 : 1,
                      }}>
                        {status === 'mastered' && '‚úì '}{group.groupNum}
                        {progress?.perfectRounds > 0 && status !== 'mastered' && status !== 'passed' && <span style={{ marginLeft: '4px', fontSize: '10px' }}>({progress.perfectRounds}/3)</span>}
                        {review && <span style={{ position: 'absolute', top: '-4px', right: '-4px', width: '8px', height: '8px', borderRadius: '50%', background: '#ef4444' }} />}
                      </button>
                    );
                  })}
                </div>
              </div>
            ))}

            <button onClick={resetProgress} style={{ width: '100%', padding: '12px', marginTop: '20px', borderRadius: '10px', border: '1px solid #ef4444', background: 'transparent', color: '#ef4444', fontSize: '13px' }}>Reset All Progress</button>
          </div>

          {sidebarOpen && <div onClick={() => setSidebarOpen(false)} style={styles.overlay} />}

          {/* Main Content */}
          <main style={styles.main}>
            {!currentGroup ? (
              <div style={{ textAlign: 'center', paddingTop: '40px' }}>
                <div style={{ fontSize: '72px', marginBottom: '16px' }}>üÄÑ</div>
                <h2 style={{ fontSize: '24px', color: '#5a4a3f', marginBottom: '8px' }}>Ready to learn?</h2>
                <p style={{ color: '#8a7a6f', marginBottom: '32px', lineHeight: '1.6' }}>100 essential Chinese words & phrases<br />Perfect for everyday conversation üíï</p>

                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '32px' }}>
                  <div style={{ background: 'white', borderRadius: '16px', padding: '20px', boxShadow: '0 4px 12px rgba(0,0,0,0.05)' }}>
                    <div style={{ fontSize: '28px', fontWeight: '700', color: '#ff8b5a' }}>{Object.values(groupProgress).filter(p => p.mastered).length}</div>
                    <div style={{ fontSize: '12px', color: '#8a7a6f' }}>Groups Mastered</div>
                  </div>
                  <div style={{ background: 'white', borderRadius: '16px', padding: '20px', boxShadow: '0 4px 12px rgba(0,0,0,0.05)' }}>
                    <div style={{ fontSize: '28px', fontWeight: '700', color: '#22c55e' }}>{accuracy}%</div>
                    <div style={{ fontSize: '12px', color: '#8a7a6f' }}>Accuracy</div>
                  </div>
                </div>

                {confidenceQueue.length > 0 && <button onClick={() => startGroup(confidenceQueue[0], true)} style={{ width: '100%', padding: '18px', marginBottom: '12px', borderRadius: '16px', background: 'linear-gradient(135deg, #ff8b5a, #f97316)', color: 'white', fontSize: '16px', fontWeight: '600', boxShadow: '0 4px 16px rgba(255,139,90,0.4)' }}>‚è∞ Confidence Review Waiting</button>}
                {miniReviewPending && <button onClick={() => startGroup(null, false, true)} style={{ width: '100%', padding: '18px', marginBottom: '12px', borderRadius: '16px', background: 'linear-gradient(135deg, #a855f7, #7c3aed)', color: 'white', fontSize: '16px', fontWeight: '600', boxShadow: '0 4px 16px rgba(168,85,247,0.4)' }}>‚ö° Mini Review Ready!</button>}
                <button onClick={() => setSidebarOpen(true)} style={{ width: '100%', padding: '18px', borderRadius: '16px', background: 'white', color: '#5a4a3f', fontSize: '16px', fontWeight: '600', boxShadow: '0 4px 12px rgba(0,0,0,0.1)' }}>üìö Choose a Group</button>
              </div>
            ) : (
              <div>
                {/* Progress Header */}
                <div style={{ background: 'white', borderRadius: '16px', padding: '16px', marginBottom: '16px', boxShadow: '0 4px 12px rgba(0,0,0,0.05)' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                    <span style={{ fontSize: '14px', fontWeight: '600', color: '#5a4a3f' }}>{isMiniReview ? '‚ö° Mini Review' : isConfidenceReview ? '‚è∞ Confidence Review' : `Phase ${currentGroup.phase} - ${currentGroup.label}`}</span>
                    <span style={{ fontSize: '12px', color: '#8a7a6f' }}>{currentCardIndex + 1} / {roundCards.length}</span>
                  </div>
                  <div style={{ height: '8px', background: '#f0e6dc', borderRadius: '4px', overflow: 'hidden', marginBottom: '12px' }}>
                    <div style={{ height: '100%', width: `${(currentCardIndex / roundCards.length) * 100}%`, background: 'linear-gradient(90deg, #ff8b5a, #f97316)', borderRadius: '4px', transition: 'width 0.3s ease' }} />
                  </div>
                  {!isMiniReview && !isConfidenceReview && (
                    <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                      <span style={{ fontSize: '11px', color: '#8a7a6f' }}>Perfect rounds:</span>
                      {[0, 1, 2].map(i => (
                        <div key={i} style={{ width: '24px', height: '24px', borderRadius: '6px', background: i < currentPerfectRounds ? '#22c55e' : '#e5e5e5', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', fontSize: '12px' }}>{i < currentPerfectRounds && '‚úì'}</div>
                      ))}
                      <span style={{ fontSize: '11px', color: '#ef4444', marginLeft: 'auto' }}>{roundErrors > 0 && `${roundErrors} error${roundErrors > 1 ? 's' : ''}`}</span>
                    </div>
                  )}
                  {estimatedTimeRemaining !== null && estimatedTimeRemaining > 0 && <div style={{ fontSize: '11px', color: '#8a7a6f', marginTop: '8px' }}>~{Math.ceil(estimatedTimeRemaining / 60)} min remaining</div>}
                </div>

                {/* Flashcard */}
                <div style={styles.card}>
                  {feedback && <div style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, background: feedback === 'correct' ? 'rgba(34,197,94,0.1)' : 'rgba(239,68,68,0.1)', pointerEvents: 'none' }} />}
                  <div style={{ fontSize: '14px', color: '#8a7a6f', marginBottom: '8px' }}>What is...</div>
                  <div style={{ fontSize: '24px', fontWeight: '600', color: '#5a4a3f', marginBottom: '24px' }}>{currentCard?.english}</div>

                  {showAnswer && (
                    <div style={{ background: 'linear-gradient(135deg, #fff3e6, #ffe8d6)', borderRadius: '16px', padding: '20px', marginBottom: '20px' }}>
                      <div style={{ fontSize: '48px', fontWeight: '700', color: '#5a4a3f', marginBottom: '8px' }}>{currentCard?.chinese}</div>
                      <div style={{ fontSize: '20px', color: '#ff8b5a', marginBottom: '4px' }}>{currentCard?.pinyin}</div>
                      <div style={{ fontSize: '12px', color: '#8a7a6f', marginTop: '12px' }}>Type the Chinese or Pinyin below to continue</div>
                    </div>
                  )}

                  <input
                    ref={inputRef}
                    type="text"
                    value={userInput}
                    onChange={(e) => setUserInput(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder={practiceMode ? "Type to practice..." : "Type Chinese or Pinyin..."}
                    autoComplete="off"
                    autoCorrect="off"
                    autoCapitalize="off"
                    spellCheck="false"
                    style={{
                      width: '100%',
                      padding: '16px 20px',
                      fontSize: '20px',
                      borderRadius: '12px',
                      border: `2px solid ${feedback === 'correct' ? '#22c55e' : feedback === 'incorrect' ? '#ef4444' : '#e5e5e5'}`,
                      textAlign: 'center',
                      background: practiceMode ? '#fff9f5' : 'white',
                      transition: 'border-color 0.2s ease',
                    }}
                  />
                </div>

                {/* Action Buttons */}
                <div style={{ display: 'grid', gridTemplateColumns: showAnswer ? '1fr' : '1fr 1fr', gap: '12px' }}>
                  {!showAnswer && <button onClick={handleDontKnow} style={{ padding: '18px', borderRadius: '14px', border: '2px solid #e5e5e5', background: 'white', color: '#8a7a6f', fontSize: '16px', fontWeight: '600' }}>I don't know ü§î</button>}
                  <button onClick={checkAnswer} disabled={!userInput.trim()} style={{ padding: '18px', borderRadius: '14px', background: userInput.trim() ? 'linear-gradient(135deg, #ff8b5a, #f97316)' : '#e5e5e5', color: userInput.trim() ? 'white' : '#a0a0a0', fontSize: '16px', fontWeight: '600', boxShadow: userInput.trim() ? '0 4px 16px rgba(255,139,90,0.4)' : 'none' }}>{practiceMode ? 'Practice ‚Üµ' : 'Check ‚Üµ'}</button>
                </div>

                <button onClick={() => setCurrentGroup(null)} style={{ width: '100%', padding: '14px', marginTop: '16px', borderRadius: '12px', background: 'transparent', color: '#8a7a6f', fontSize: '14px' }}>Exit Round</button>
              </div>
            )}
          </main>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<FlashcardApp />);
  </script>
</body>
</html>
